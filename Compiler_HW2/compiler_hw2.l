/* Definition section */
%{
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
	
/* Struct */
typedef union _DATA{
    int     idata;
    double  fdata;
    char    sdata[101];
    bool    bdata;
}DATA;

typedef struct _INT_FLOAT{
    int     type;
    DATA    data;
}INT_FLOAT;

typedef struct _Variable{
    char    id[100];
    char    kind[10];
    char    attribute[1000];
    INT_FLOAT  Val;
}Variable;

struct Table{
    int index;
    int depth;
    Variable Var[1001];
    struct Table* prev;
    struct Table* next;
};


#include "y.tab.h"	/* header file generated by bison */
extern YYSTYPE yylval; //YYSTYPE
char buf[256];  //BUF_SIZE

/* This macro is used to record code line */
#define CONCAT { memset(buf,' ',1); strncat(buf, yytext, 256 - strlen(buf) - 2); }
#define FREE { memset(buf, '\0', 256); }
%}

/* Define regular expression label */
digit		[0-9]
negdigit	[-][0-9]
letter		[a-zA-Z]
integer         {digit}+
float          	{digit}+"."{digit}+
neginteger	[-]{digit}+
negfloat	[-]{digit}+"."{digit}+
id		{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { CONCAT; return(ADD); }
"-" 	{ CONCAT; return(SUB); }
"*" 	{ CONCAT; return(MUL); }
"/" 	{ CONCAT; return(DIV); }
"%"     { CONCAT; return(MOD); }
"++"    { CONCAT; return(INC); }
"--"    { CONCAT; return(DEC); }

 /* Relational */
">"	{ CONCAT; return(MT); }
"<"	{ CONCAT; return(LT); }
">="	{ CONCAT; return(MTE); }
"<="	{ CONCAT; return(LTE); }
"=="	{ CONCAT; return(EQ); }
"!="	{ CONCAT; return(NE); }

 /* Assignment */
"="	{ CONCAT; return(ASGN); }
"+="	{ CONCAT; return(ADDASGN); }
"-="	{ CONCAT; return(SUBASGN); }
"*="	{ CONCAT; return(MULASGN); }
"/="	{ CONCAT; return(DIVASGN); }
"%="	{ CONCAT; return(MODASGN); }

 /* Logical */
"&&"	{ CONCAT; return(AND); }
"||"	{ CONCAT; return(OR); }
"!"	{ CONCAT; return(NOT); }

 /* Delimiters */
"("	{ CONCAT; return(LB); }
")"	{ CONCAT; return(RB); }
"{"	{ CONCAT; return(LCB); }
"}"	{ CONCAT; return(RCB); }
"["     { CONCAT; return(LSB); }
"]"     { CONCAT; return(RSB); }
","     { CONCAT; return(COMMA); }

 /* Print Keywords */	
"print"		{ CONCAT; return(PRINT); }

 /* Condition and Loop Keywords */
"if"		{ CONCAT; return(IF); }
"else"		{ CONCAT; return(ELSE); }
"for"		{ CONCAT; return(FOR); }
"while"		{ CONCAT; return(WHILE); }

 /* Declaration Keywords */
"void"          { CONCAT; return(VOID); }
"int"		{ CONCAT; return(INT); }
"float"		{ CONCAT; return(FLOAT); }
"string"	{ CONCAT; return(STRING); }
"bool"		{ CONCAT; return(BOOL); }

 /* boolean Keywords */ 
"true"		{ CONCAT; return(TRUE); }
"false"		{ CONCAT; return(FALSE); }

"return"	{ CONCAT; return(RET); }
"continue"	{ CONCAT; return(CONT); }
"break"		{ CONCAT; return(BREAK); }

 /* String Constant */
\"				{ CONCAT; BEGIN STRING_STATE;}
<STRING_STATE>\"		{ CONCAT; BEGIN INITIAL;}
<STRING_STATE>[^"]*		{ CONCAT; yylval.string = strdup(yytext); return(STRING);}

 /* Number Constant */
{integer}	{ CONCAT; yylval.i_val = atoi(yytext);  return(I_CONST); }
{float}		{ CONCAT; yylval.f_val = atof(yytext);  return(F_CONST); }
{neginteger}    { CONCAT; yylval.i_val = atoi(yytext);  return(I_CONST); }
{negfloat}      { CONCAT; yylval.f_val = atof(yytext);  return(F_CONST); }

 /* C type Comment */
"/*"			{ CONCAT; BEGIN COMMENT; }
<COMMENT>[^*\n]+	{ CONCAT; }
<COMMENT>\n		{ printf("%d:%s\n",yylineno, buf); FREE; }
<COMMENT>"*"		{ CONCAT; }
<COMMENT>"*/"		{ CONCAT; BEGIN INITIAL; }

 /* C++ type Comment */
\/\/.*	{ CONCAT; }

 /* Variable ID */
 {id}           { CONCAT; yylval.string = strdup(yytext); return(ID);}

 /* others */
" "		{ CONCAT; }
[;]             { CONCAT; return(SEMICOLON);}
[\n]		{ printf("%d:%s\n",yylineno, buf); FREE; return NEWLINE;}
[ \t]		{ }
[^ \t\n]        { } /* Ignore other charactor sets */
<<EOF>>         { return 0; }

%%

int yywrap()
{
    return 1;
}
